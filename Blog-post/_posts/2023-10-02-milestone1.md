---
layout: post
title:  "LIFT 6758 Project: Milestone 1"
subtitle: "Six Subtitle"
date:   2023-10-02
---


## 1. Data Acquisition
<b> NHL Stats API </b><br>

The NHL offers an API that provides access to extensive play by play information for all NHL games, including both regular season and playoff matches. This data is highly detailed. We can utilise this data for analysis of aspects such as individual player performance and team patterns.

To obtain the play by play data, for a game we send a GET request to the following API endpoint;
{% highlight python %}
https://statsapi.web.nhl.com/api/v1/game/ <game_id> /feed/live/
{% endhighlight %}

with <game_id> representing the ID of the game you want to retrieve data for. All other useful REST endpoints can be found at the unofficial API found here: https://gitlab.com/dword4/nhlapi/-/blob/master/stats-api.md


<b> Extracting Data for a single Game </b><br>

Since we've identified the correct endpoint of interest using the <game_id>, we now want a means to extract the data. We can utilise the Python requests API (https://pypi.org/project/requests/) using the follwing code snippit:

{% highlight python %}
requests.get('https://statsapi.web.nhl.com/api/v1/game/'+str(game_id)+'/feed/live/')
{% endhighlight %}

This will give us a JSON extract of the play-by-play data for that one game.

<b> Extracting Data for Seasons</b><br>

To get all data for specified seasons we need a way of getting all game_ids for a specific season first. To get that we can utilise the NHL API schedule endpoint (https://statsapi.web.nhl.com/api/v1/schedule) to get all game_ids for a specified season. The function we have that does just that that is:

{% highlight python %}
_get_associated_game_ids(self, game_type: str, season: str)
{% endhighlight %}

where gamt_type can be either 'R' for Regular or 'P' for Playoffs and season is a string of the speicfied season, Ex. "20162017". _get_associated_game_ids() is a private method as it is an internal helper function to get all data for a season defined as:

{% highlight python %}
download_play_by_play_data_for_season(self, season: str, game_type:str)
{% endhighlight %}

Using this method we can retrieve all data for a single season/game-type specified. We can then all combinations of seasons and playoffs and then retriesve all data needed. We achieve this in the following accessbile function:

{% highlight python %}
download_all_play_by_play_data(self, seasons:list, game_types:list)
{% endhighlight %}

where seasons is a list of seasons and game_types list of all data needed. Example usage:

{% highlight python %}
from dataAcquisition import DataAcquisition

data_aquirer = DataAcquisition()
seasons = ['20162017', '20172018', '20182019', '20192020', '20202021']
game_types = ['R', 'P']

data_aquirer.download_all_play_by_play_data(seasons, game_types)
{% endhighlight %}

All JSONs will be downloaded under a "data/" directory under your current directory.


## 2. Interactive Debugging Tool
*    The widgets has been made by ipywidgets library and widgets.


    game_type = widgets.Dropdown(
    options = ['Regular', 'Play_off'],
    description = 'Type of the game :',
    disabled = False
    )
    def handle_game_type(change):
        new_value = change.new


    year_of_the_game = widgets.Dropdown(
        options = [2016, 2017, 2018, 2019, 2020],
        description = 'year of the game',
        disabled = False
    )
    def handle_year_of_the_game(change):
        new_value = change.new

    game_id = widgets.IntSlider(
        min= 1,
        max = 1271,
        description='game number',
        disabled=False
    )
    def handle_game_id(change):
        new_value = change.new

    event = widgets.IntSlider(
        min= 1,
        max = 100,
        description='events',
        disabled=False,
    )
    def handle_event(change):
        new_value = change.new


   

*    placing the widgets in a right order.

    inters = widgets.VBox([widgets.HBox([game_type, year_of_the_game]),widgets.HBox([game_id, event])])

*   Obtaining the exact event from entries and creating the adresses 


    serial_number = 20000 if game_type == 'Regular' else 30000
    json_file = f'{year_of_the_game}0{int(serial_number) + int(game_id)}'
    gtype = 'R' if game_type == 'Regular' else 'P'


    

*   Opening data json file
    with open(f'data/{year_of_the_game}/{gtype}/{json_file}.json') as f:
        game_info = json.load(f)
    f.close()

    

*   obtaining the information from json:

        home_team = game_info['gameData']["teams"]["home"]["abbreviation"]
        away_team = game_info['gameData']["teams"]["away"]["abbreviation"]
        home_team_goal = game_info['liveData']["linescore"]["teams"]["home"]["goals"]
        away_team_goal = game_info['liveData']["linescore"]["teams"]["away"]["goals"]
        home_team_goal_shots_on_goal = game_info['liveData']["linescore"]["teams"]["home"]["shotsOnGoal"]
        away_team_goal_shots_on_goal = game_info['liveData']["linescore"]["teams"]["away"]["shotsOnGoal"]
        home_team_so = game_info['liveData']["linescore"]["shootoutInfo"]["home"]["scores"]
        away_team_so = game_info['liveData']["linescore"]["shootoutInfo"]["away"]["scores"]
        home_team_attempts = game_info['liveData']["linescore"]["shootoutInfo"]["home"]["attempts"]
        away_team_attempts = game_info['liveData']["linescore"]["shootoutInfo"]["away"]["attempts"]
        event_time = game_info['liveData']['plays']['allPlays'][event]["about"]["periodTime"]
        event_des = game_info['liveData']['plays']['allPlays'][event]["result"]["description"]
        period_time = game_info['liveData']['plays']['allPlays'][event]["about"]["periodTime"]    
        period = game_info['liveData']['plays']['allPlays'][event]["about"]["period"]
        home_data = pd.DataFrame({'Home':[home_team, home_team_goal, home_team_goal_shots_on_goal, home_team_so, home_team_attempts],
                                'Away':[away_team, away_team_goal, away_team_goal_shots_on_goal, away_team_so, away_team_attempts]
                                }, index= ['Teams:','Goals:','Shots on goal:','SO:','Attempts'])
    * Printing the useful information


        print(f"game_id : {game_info['gamePk']}")
        print(f"total games : {len(os.listdir(f'data/{year_of_the_game}/{gtype}'))}")
        print(f"total events : {len(game_info['liveData']['plays']['allPlays'])}")
        print(f"date time {game_info['gameData']['datetime']['dateTime']}")
        print(home_data)
    
*   Creating the figures 

        fig = plt.figure(figsize=(8, 4))
        img = mpimg.imread('imgs/nhl_rink.png')
        fig, ax = plt.subplots()
        ax.imshow(img,extent=[-100, 100, -42.5, 42.5])
        plt.xlim((-100, 100))
        plt.ylim((-42.5, 42.5))
        my_y_ticks = np.arange(-42.5, 42.5, 21.25)
        plt.yticks(my_y_ticks)
        plt.xlabel('feet')
        plt.ylabel('feet')


        if period % 2 == 1:
            plt.title(f'{event}' + '\n' + f'{period_time}' + f'{period}' + '\n'+ f'{away_team}' + '      VS    ' + f'{home_team}')
        else:
            plt.title(f'{event}' + '\n' + f'{period_time}' + f'{period}' + '\n'+ f'{home_team}' + '      VS    ' + f'{away_team}')

        cors = game_info['liveData']['plays']['allPlays'][event]['coordinates']



        try:
            x, y = cors['x'], cors['y']
            plt.plot(x, y, 'bo')
            plt.annotate(' <'+str(x)+', '+str(y)+'>', xy=(x, y))
        except:
            plt.text(-23, 45, "No ball included !", c='r')

        plt.show()
        pprint.pprint(game_info['liveData']['plays']['allPlays'][event]['result'])


    The tool in this part is an interactive tool to see the game information.
    
     It contains the type of the game that we can choose the type base on play off and regular.
     
    Year of the game that contains years of 2016, 2017, 2018, 2019, 2020. The index bar is indentifier of the game. The index bar on the right is counter of the events in a game.


    After choosing the game based on the specifications, we get the information related to the game and the map of the event where and when it happened.
    
     Also we can see who made the event and what is the result.


![](/nhl_ds_project/figures/info.png)


![](nhl_ds_project/figures/eventmap.png)



    here we have the game mode "Play off", in 2019, game number 174, event 54.

## 3. Tidy Data
(Your content goes here)

## 4. Simple Visualizations
(Your content goes here)

## 5. Advanced Visualizations: Shot Maps

<iframe src="https://github.com/mahmoodhegazy/nhl_ds_project/blob/main/figures/html/shot_map_2016-2017.html" height="600px" width="100%" style="border:none;"></iframe>


<iframe src="https://github.com/mahmoodhegazy/nhl_ds_project/blob/main/figures/html/shot_map_2017-2018.html" height="600px" width="100%" style="border:none;"></iframe>


<iframe src="https://github.com/mahmoodhegazy/nhl_ds_project/blob/main/figures/html/shot_map_2018-2019.html" height="600px" width="100%" style="border:none;"></iframe>


<iframe src="https://github.com/mahmoodhegazy/nhl_ds_project/blob/main/figures/html/shot_map_2019-2020.html" height="600px" width="100%" style="border:none;"></iframe>


<iframe src="https://github.com/mahmoodhegazy/nhl_ds_project/blob/main/figures/html/shot_map_2020-2021.html" height="600px" width="100%" style="border:none;"></iframe>

* The rate of a team shots and heatmap of their shots as well as their diffences. For example, most of the teams have shotted when they were near the net. Most of the defences were at the middle near the net. Majority of the teams shotted from sides while some teams such as Vancuver canucks Shotted when they were at the middle side

* During the 2016-2017 season, the Colorado Avalanche displayed a notably reduced shot frequency in the near area of the net, approximately 15-25 feet away from it, in contrast to the league's standard shot frequency from the same spot.

    In the 2020-2021 season, the Colorado Avalanche had a different way of play-style, as they show a higher-than-average shot frequency near the net, indicating a significant difference in their approach to the game.

* Shot Range:

    Both teams tend to take shots in the near-to-mid-range area, which is 10 to 50 feet away from the net. This suggests that they prefer quality scoring opportunities rather than long-range attempts.
    Buffalo Sabres:

    The Sabres show a relatively balanced approach in terms of shot distribution on the left and right sides of the net.
    They tend to have fewer shots in the middle position, which could indicate a preference for shooting from the sides.
    This pattern may suggest that the Sabres are trying to create scoring chances from various angles.
    Tampa Bay Lightning:

    The Tampa Bay Lightning's shot map reveals a concentration of shots in the middle position.
    They appear to have a strategic focus on the high-scoring central area in front of the net.
    The Lightning takes fewer shots from the sides, indicating that they rely more on plays through the center, possibly exploiting opportunities in front of the net.
    Style and Strategy:

    Buffalo's approach of distributing shots across the left and right sides might be an attempt to make their attack more diverse, taking advantage of opportunities that arise on both sides.
    Tampa Bay's emphasis on the middle position may reflect a strategy to capitalize on high-percentage scoring chances in the most critical area in front of the net.

    Overall, The Lightning's success could be attributed to their strategy of capitalizing on high-percentage scoring opportunities in front of the net. Their focus on the middle position indicates a strong commitment to effective offensive plays and converting these chances into goals.


    The shot-diffence distribution observations provide valuable insights, but they do not offer a comprehensive explanation for a team's performance. For instance we do not have any information about team chemistry, coaching, and leadership.